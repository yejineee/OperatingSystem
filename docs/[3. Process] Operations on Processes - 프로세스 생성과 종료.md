

# [3. Process] Operations on Processes - 프로세스 생성과 종료 

## 🥨 프로세스 생성

- a Tree of Processes in Linux

![](https://i.imgur.com/qiFETK4.png)

### ✔️ 트리 구조의 프로세스

실행하는 동안, 프로세스는 다른 프로세스를 생성할 수 있다. 

프로세스가 새로운 프로세스를 생성하면, 그 관계는 **부모(parent) 프로세스**와 **자식(child) 프로세스**관계가 된다. 

부모 프로세스는 자식프로세스에게 subtask를 할당시키고, wait()으로 자식 프로세스가 끝나기를 기다릴 수 있다.

자식 프로세스 또한 새로운 프로세스를 만들 수 있다. 

결국 프로세스의 관계는 **트리 구조**를 만들게 된다. 

### ✔️ PID

각 프로세스는 process identifier, 줄여서 **PID**라고 불리는 고유한 값을 갖고 있다. 

이 값은 커널에서 프로세스의 속성에 접근할 때 사용할 index로 사용된다.

### ✔️ init process

init 프로세스는 트리의 루트로서, 모든 유저 프로세스의 직간접적으로 부모가 된다. 

이 프로세스는 모든 고아 프로세스(orphan process)의 부모 프로세스가 된다.

init process는 주기적으로`wait()` 시스템 콜을 호출하여 종료된 고아 프로세스가 갖고 있던 자원을 해제하는 작업을 한다. 즉, PID와 process table의 entry를 해제한다.

init process는 이제 systemd 프로세스가 그 역할을 한다.

![](https://i.imgur.com/DMeHdP0.png)


### ✔️ 프로세스 생성과 자원 할당

자식 프로세스가 생성되면, 일을 처리하기 위한 cpu time, 메모리, 파일, I/O 장치와 같은 자원(resource)이 필요하다. 

자식 프로세스는 이러한 자원을 

1. 운영체제로 부터 직접 얻거나,

2. 부모 프로세스 자원의 일부분(subset)을 갖는 것으로 제한된다.

부모 프로세스는 

1. 자식 프로세스들과 자원을 구분(partition)하거나,

2. 메모리나 파일과 같은 자원들을 공유(share)해야 한다. 

자식 프로세스가 부모 프로세스의 자원 중 일부분만 갖도록 제한함으로써, 너무 많은 자식 프로세스가 생김으로 인하여 생기는 시스템의 오버로딩을 막는다.

### ✔️ 프로세스 생성과 실행

새로운 프로세스가 생성되면, 부모와 자식 프로세스의 실행은 두 가지로 나뉘게 된다.

1. 부모 프로세스는 자식 프로세스와 concurrent하게 실행된다.

2. 부모 프로세스는 자식 프로세스 중 일부나 전체가 종료하기를 기다린다.(wait)

### ✔️ 프로세스 생성과 메모리 영역

프로세스가 생성되면 메모리 영역은 두 가지로 나뉘게 된다.

1. 자식 프로세스는 부모 프로세스의 복제본을 갖는다. 
	
	=> 자식 프로세스는 부모 프로세스와 같은 프로그램과 데이터를 갖는다.

2. 자식 프로세스는 새로운 프로그램을 메모리에 올린다. 
	
### ✔️ UNIX 운영체제에서의 프로세스 생성

![](https://i.imgur.com/0ZxFY4B.png)


- 프로세스 생성 

	UNIX 프로세스에서는 **`fork()`** 시스템 콜로 새로운 프로세스를 생성할 수 있다.

	새로운 프로세스의 메모리 영역은 부모 프로세스의 메모리 영역과 다르다.
	
	그러나 자식 프로세스의 초기 메모리 영역은 **부모 프로세스가 fork() 했을 시점의 메모리 영역과 같은 내용**이다.

	이는 부모 프로세스가 자식 프로세스와 쉽게 소통할 수 있게 한다.
	
	부모와 자식 프로세스는 fork()이후 시점부터 각자 계속해서 실행된다. 

	`fork()`의 리턴 코드가 0이면 자식 프로세스이고, 0이 아니면 부모 프로세스이며, 이 때 리턴코드는 자식 프로세스의 PID이다. -1이면 새로운 프로세스가 생성되지 않은 것이다.

- 메모리 덮어 씌우기

	`fork()` 이후로 두 프로세스 중 하나는 일반적으로 **`exec()`** 시스템 콜을 호출한다.
	
	`exec()`는 기존의 프로세스 이미지를 새로운 프로세스 이미지로 바꾸고, 그것을 실행한다.
	
- 자식 프로세스의 종료 기다리기

	부모 프로세스는 자식 프로세스가 실행될 동안, **`wait()`** 시스템 콜을 호출하여, 자신은 레디큐에 들어갈 수 있다. 
	
	자식 프로세스가 종료되면, 부모 프로세스는 `wait()`을 호출한 이후부터 다시 실행하게 된다.

	자식 프로세스는 종료되면 **zombie process**가 된다.
	
	이 때, 자식 프로세스가 갖고 있던 자원들(물리적 메모리, 가상 메모리, open file, I/O buffer 등)은 해제된다. 
	
	그러나, PID와 process table에서의 entry는 해제되지 않는다. 
	
	부모 프로세스가 `wait()`을 호출하였을 때, 자식 프로세스의 PID와 process table에서의 entry가 해제된다. 
	

## 🥨 프로세스 종료

프로세스가 실행을 마쳤을 때는 두 가지 방법으로 종료될 수 있다.

직접적으로는 **`exit()`** 시스템 콜을 호출하여 OS에게 종료되었음을 알린다.

간접적으로는 **main()에서 return**을 하는 것이다.

### ✔️ exit() system call

프로세스는 종료되는 시점에 프로세스가 갖고 있던 자원들은(물리, 가상 메모리, open file, I/O buffer) 해제된다.

프로세스는 종료될 때, exit status를 파라미터로 건네주고 종료할 수 있다.

```c
exit(1);
```

부모 프로세스는 `wait()` 시스템 콜에 파라미터를 전달하여, 자식 프로세스의 exit status를 받아볼 수 있다. 

또한, wait()의 리턴값은 종료된 자식 프로세스의 PID이다. 

이를 통해 어떤 자식 프로세스가 종료되었는지를 알 수 있다.

```c
pid_t pid;
int status;

pid = wait(&status);
```

### ✔️ abort() system call

부모 프로세스는 자식 프로세스의 실행을 abort() 시스템 콜로 종료시킬 수 있다.

그 이유로는 

1. 자식 프로세스가 너무 많은 자원을 잡아먹을 때

2. 자식 프로세스의 task가 더이상 필요 없을 때

3. 부모 프로세스가 exit한다면, OS는 부모프로세스가 종료되기 전에 자식 프로세스들을 종료시킨다. 
	- 이를 **Cascading termination**이라고 한다. 즉, OS는 부모 프로세스가 종료되면, 그의 모든 자식 프로세스를 종료시킨다. 

### ✔️ 좀비 프로세스 (zombie process)

> On Unix and Unix-like computer operating systems, a zombie process or defunct process is **a process that has completed execution (via the exit system call) but still has an entry in the process table**: it is a process in the "Terminated state". - Wikipedia 

자식 프로세스는 종료된 시점에 zombie state에 들어간다. 

부모 프로세스가 wait()을 호출한 시점에 PID와 process table의 entry가 해제된다.

만약 **부모 프로세스가 자식 프로세스의 종료되었는데도 wait()을 호출하지 않으면, 자식 프로세스는 그대로 zombie process**로 남아있다.

### ✔️ 고아 프로세스 (orphan process)

만약 **부모 프로세스가 wait()을 호출하지 않고 종료**해버리면, 그 자식 프로세스는 **고아 프로세스**가 된다. 

유닉스와 리눅스에서는 이 경우에 *init* process를 고아 프로세스의 부모 프로세스로 지정한다.

init process는 주기적으로 wait()을 호출하여, 종료된 고아 프로세스의 exit status를 수집하고, 그의 자원(PID, process-table entry)를 해제한다.
